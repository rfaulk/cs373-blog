---
layout: post
title: Week 3
---
###What did you do this past week?
There wasn't a lot of SWE in my week, but my partner and I spent a few hours on Netflix. After setting up all usual plumbing and selecting a couple of caches, we were able to get an RMSE of 1.03 without any cleverness, and a little shifting will get us the rest of the way. This would've been suprising, but I'd already heard the rumor that Netflix was easier than Collatz.

###What is in your way?
As usual, balancing competing classes is my biggest burden, but this next week should be a little lighter.

###What will you do next week?
I'll finish up Netflix, which shouldn't take long, but more emphatically, I'll do all the readings.

This week was another hell. I didn't sleep much and even contemplated dropping a class (not this one :P), but I pulled through!

Again, most of my attention deviated from SWE, but as I mentioned, we got our early start on Netflix. I find myself a little glum about this project. It's a very cool concept, analyzing a large dataset: trekking out and building your very own personal algorithm. But alas, the sub-1.0 RMSE requirement is too generous, so it's definitely a "what you make of it" project. There's extra credit for a better RMSE, but it's a hard sell when I'm elsewhere pressed for time.

In class, we're getting to the more interesting bits of Python. I'm using the language in three classes this semester, so it's going to be quite the welcome refresher. This week we started touching on one of my favorite aspects of the language: interoperability. A lot of languages try to do this with abstract types and overloadable operators, but Python's combination of dynamic typing and magic methods really stands above. In class, we focused on interables. In addition to iteraton and the standard overloadng of operators, you can have your classes work with built-in functions like abs(), reversed(), and even with type conversions. This lets you easily code up slew of classes that interact beautifully with each other and the Python libraries.

This all comes at a price, though. By not explicitly enforcing a well-defined type hierarchy, the language loses a lot of its rigidity. As I've experienced far too much this week in Distributed Computing, dynamic typing lets simple human errors meander and linger in unsuspecting places. This is doubly punishing due to the fact that Python barely checks anything about a line of code before running it. I wrote a cool interoperable message passing system that could treat different message schemes the same before final dispatch without feeling like I was fighting the language to do so (as I felt with Java doing something similar). However, this lead to a lot of problems where a malformed method call or type mismatch would come to bear in a confusing and seemingly unrelated piece of code three levels down.

It's definitely an acquirable skill. I made far less of these mistakes once my C++-coddled brain started thinking about the types and proofreading for itself instead, but the conveniences of Python certainly aren't free.


**Tip of the week:** Alarm clocks with math are really cool. I've mastered deactivating alarms without waking up. On Wednesday, I turned both of mine off and missed the first two minutes of SWE (and the quiz!). Now I've I finally caved and gone back to using [Alarm Clock Xtreme](https://play.google.com/store/apps/details?id=com.alarmclock.xtreme.free). It's a good alarm clock with a lots of features, the best being the ability to lock your alarm with math problems. It can be a pain. A big one. But it's worth it to stop worrying about whether or not I'll Houdini my way out of another morning class.
